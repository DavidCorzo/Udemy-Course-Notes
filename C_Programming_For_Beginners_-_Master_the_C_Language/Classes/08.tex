\section{Overview}
\begin{itemize}
    \item A function is a self-contained unit of a program code designed to accomplish a particular task.
    \item Something you can invoke to do something. 
    \item Syntax rules define the structure of a function and how it can be used.
    \item A function in C is the same as subroutines or procedures in other programming languages. 
    \item Some functions cause an action.
    \item Functions allow divide and conquer strategy. 
    \item It's very hard to do everything in the main function. 
    \item Functions make it easier to debug and test, also to maintain. 
    \item Functions can separate sub-tasks, you can further subdivide.
    \item Reduces overall complexity. 
    \item Functions reduce code repetition, you can write a function to a library, and they can be invoked, they can be reused. 
    \item Advantages: 
        \begin{itemize}
            \item Helps with readability. 
            \item Program is better organized. 
            \item Easier o read and easier to maintain (maintaining is often the most expensive part in a program).
        \end{itemize}
    
    \item Functions make it easier to work in teams, to develop large projects and can be debugged independently. This reduces overall development time. 
    \item Functions, since they can be reused, this means you can use it again and again instead of writing the code again and again. 
    \item View functions like a black box: input and output. Functions are all about input and output. 
    \item It's important to think before writing a program, functions can obligate you to do so. 
    \item You can pass data inside the parentheses, called arguments. Data can be also returned, this is useful when we need a result and assign it to a variable. 
\end{itemize}
\subsection{Implementing functions}
\begin{itemize}
    \item You can create your own functions. 
    \item Remember to also use self documenting names for functions. 
    \item Functions are implemented $\rightarrow$ invoked $\rightarrow$ pass and return data from them. 
\end{itemize}

%----------------------------------------------------------------------------------------
\section{Defining functions}
\begin{itemize}
    \item Defining a function is saying that a function exists and does something if the right data is passed to it. 
    \item Functions always use curly braces, you can't skip the curly braces even if the function just uses one statement. 
    \item In between the braces is called the function body, the name, type and parameters are called the function header. 
    \item The data passed to a function can be manipulated in any normal way and that manipulated data can be returned. 
    \item Syntax is: \placeholder{return type} \placeholder{name of function} \verb|{ statements; }|
    \item The header tells the compiler three things, the type it will return, the function name and the arguments it takes in. 
    \item \verb|void| is a function that doesn't return anything. 
    \item The braces of the function body can be empty, however the function must always have curly braces. 
    \item Naming functions follow the same rules as the variables, you can't have two functions with the same name, each must be unique, you can't name a function keyword names such as \verb|sizeof|. Don't name your functions the same as standard library functions. 
    \item Naming functions: \verb|camelCase|, \verb|snake_case|, \verb|Capitalize|
    \item Function prototypes: a statement that defines the functions, also called function signature, you want to write a function prototype the same way you write the function header. Function prototypes are usually defined in a header file. If they are used by various programs you should place it in a header file. 
    \item You don't have to have the same parameter names when you pass in data in variables. 
    \item Its good practice to always include declarations for all the functions in a program source file regardless of where they are called, this will help your programs be more consistent in design, it will also prevent errors from occurring if, at any stage, you choose to call a function from another part of you program. 
    \item Example of function prototypes: 
        \begin{minted}[autogobble]{c}
            #include directives 
            // func prototypes
            double average(double data_val[], size_t count);
            double sum(double*x, size_t n);
            size_t get_data(double*, size_t); 
            
            int main(void){
                statements;
            }
            // define funcs
            average(){
                statements; 
            }
        \end{minted}
\end{itemize}
\subsection{Example}
\inputcode{\lang}{\code/function_prototypes.c}

%----------------------------------------------------------------------------------------
\section{Arguments and parameters}
\begin{itemize}
    \item A parameter is a variable in a function declaration and function definition / implementation. 
    \item When a function is called, the arguments are the data that you pass into the function parameters. The actual value of a variable that gets past to a function. 
    \item Function parameters are defined within the function header. 
    \item The parameters for a function are a list of parameter names with their types. 
    \item If the function doesn't require any parameters its good practice to put the keyword void inside the parentheses. 
    \item The names of the parameters are local to the function. 
    \item The body of the function should use these parameters in its implementation. 
    \item You may have inside the body other declared and initialized variable. 
    \item When passing an array as an argument to a function, you must: 
        \begin{itemize}
            \item Pass an additional argument specifying the size of the array. 
            \item The function has no means of knowing how many elements are in the array. 
        \end{itemize}
    \item Parameters greatly increase the usefulness and flexibility of a function. If the printf() wouldn't have parameters it wouldn't be useful.
    \item It's a good idea to add comments before each of your own function definitions. 
\end{itemize}
\subsection{Example}
\inputcode{\lang}{\code/functions_defining.c}

%----------------------------------------------------------------------------------------
\section{Returning data}
\begin{itemize}
    \item Functions can return data using specific syntax. 
    \item Example: 
        \begin{minted}[autogobble]{c}
            /*type*/ func(params){
                /* statements */; 
                return something;
            }
        \end{minted}
    
    \item You can specify the type of value to be returned by a function as any of the legal types in C, includes enumeration types and pointers. 
    \item void means that no data will be returned. 
    \item Return statement: if you provide the return function like this \mintinline{c}{return;} this means that you are just simply exiting the function, you use it in a void function. In the function header you declared the data that will be returned, the function has to return type in accordance with the function header. Use \mintinline{c}{return something;} when this is the case. 
    \item If you return something that can be converted, the compiler will implicitly convert it, this can cause bugs. If it can't implicitly convert you will get a compiler error. 
    \item You can have multiple returns in one functions.  
    \item Invoking a function: you invoke a function you call it by name, you then pass in the parameters, order matters, you must pass the data in the same way in which it's declared in the function header. 
    \item Parameters can also be expressions that result in a given and accepted type. 
    \item You can assign function returns to variables, like so: \mintinline{c}{int x = my_func();} use the equals operator. 
    \item If the function returns data and you don't care about that data you don't need to assign it to a variable, you can just use it as a void. The compiler will not complain if you don't use the data returned from function calls. 
\end{itemize}
\subsection{Example}
\inputcode{\lang}{\code/returning_func.c}


%----------------------------------------------------------------------------------------
\section{Local and global variables}
\begin{itemize}
    \item Variables defined inside a function are known as automatic local variable, you can't access that variable from another one, it's only accessible from where it's defined. 
    \item If an initial value is given to a variable inside a function, that initial value is assigned to the variable each time the function is called. 
    \item You can use a static variable to counter this effect, for example if you were to want to calculate the number of times a function was called you can declare a static variable and access it locally and globally. Just regular local variables are going to have different values each time.
    \item Use the auto keyword to be more precise, but the compiler usually adds it by default. 
    \item Local variables are also applicable to any code where the variable is created in a block (loops, ifs, etc. ), a block is where the brackets start and end. 
    \item If you have an if statement declared inside a block, you are going to be able to access it only inside that block, not outside. 
    \item Global variables: the opposite of local variables, a global variable can be used by all functions, this means putting it outside the main function. 
    \item Global variables are declared outside any function, they don't belong to any particular function. 
    \item This type of variable is alive for the entirety of the program, from when it starts to when it ends. 
    \item Any function in the program can change the value of that global variable. 
    \item If there is a global variable and a local variable with the same name, the local variable will take precedence. Global variable if you have variables with the same name locally. 
    \item Avoid using global variables: global variables cause coupling between functions (dependencies), difficult to debug functions this way, if one function doesn't work and you fix it, you may cause other functions to malfunction. 
        \begin{itemize}
            \item Hard to find the location of a bug in a program. 
            \item Hard o fix a bug once it's found because other functions can malfunction (dependency issues). 
        \end{itemize}
    \item Use parameters instead of a global variable. 
    \item If you do use global data, document that is global always; some modern programming languages actually abolished the idea of global variables because they are so inconvenient. 
\end{itemize}
\subsection{Example}
\inputcode{\lang}{\code/global_local.c}


%----------------------------------------------------------------------------------------
\section{Challenge Write some functions}
\inputcode{\lang}{\code/challenge_write_some_func.c}
\inputcode{\lang}{\code/challenge_tic_tac_toe.c}
