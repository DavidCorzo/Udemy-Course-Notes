\BOOKMARK [0][-]{chapter.1}{All about the stack}{}% 1
\BOOKMARK [1][-]{section.1.1}{Introduction to the stack}{chapter.1}% 2
\BOOKMARK [2][-]{subsection.1.1.1}{Example of the stack and the push, pop method}{section.1.1}% 3
\BOOKMARK [1][-]{section.1.2}{Practical examples where stacks are used}{chapter.1}% 4
\BOOKMARK [1][-]{section.1.3}{Basic algorithm for stack data structure}{chapter.1}% 5
\BOOKMARK [1][-]{section.1.4}{Implementation of stack - Code along}{chapter.1}% 6
\BOOKMARK [1][-]{section.1.5}{Making a menu for the stack}{chapter.1}% 7
\BOOKMARK [1][-]{section.1.6}{Dynamic memory in the usage of our stack, stack evolution}{chapter.1}% 8
\BOOKMARK [1][-]{section.1.7}{Stack in action - Decimal to binary conversion}{chapter.1}% 9
\BOOKMARK [2][-]{subsection.1.7.1}{Decimal to binary conversion}{section.1.7}% 10
\BOOKMARK [2][-]{subsection.1.7.2}{Let's implement the function printBinary}{section.1.7}% 11
\BOOKMARK [1][-]{section.1.8}{Stack in action: Reversing the content of a text file}{chapter.1}% 12
\BOOKMARK [0][-]{chapter.2}{Step-by-step developing a parenthesis checking program}{}% 13
\BOOKMARK [1][-]{section.2.1}{Understanding the problem}{chapter.2}% 14
\BOOKMARK [2][-]{subsection.2.1.1}{Example}{section.2.1}% 15
\BOOKMARK [2][-]{subsection.2.1.2}{Errors}{section.2.1}% 16
\BOOKMARK [1][-]{section.2.2}{Developing the algorithm for bracket checking}{chapter.2}% 17
\BOOKMARK [1][-]{section.2.3}{Implementation of parenthesis checking program}{chapter.2}% 18
\BOOKMARK [0][-]{chapter.3}{Polish notation and reverse polish notation}{}% 19
\BOOKMARK [1][-]{section.3.1}{Polish \046 Reverse polish notations}{chapter.3}% 20
\BOOKMARK [2][-]{subsection.3.1.1}{Polish notation}{section.3.1}% 21
\BOOKMARK [2][-]{subsection.3.1.2}{Reverse polish notation}{section.3.1}% 22
\BOOKMARK [1][-]{section.3.2}{Understanding precedence of operators, conversion idea - infix to prefix/post-fix}{chapter.3}% 23
\BOOKMARK [1][-]{section.3.3}{How to evaluate polish or reverse polish notation}{chapter.3}% 24
\BOOKMARK [1][-]{section.3.4}{Algorithm for evaluating post-fix expression}{chapter.3}% 25
\BOOKMARK [1][-]{section.3.5}{Implementing evaluation of post-fix expressions with the C programming language}{chapter.3}% 26
\BOOKMARK [1][-]{section.3.6}{Understanding the precedence function}{chapter.3}% 27
\BOOKMARK [1][-]{section.3.7}{Explaining how it works}{chapter.3}% 28
\BOOKMARK [2][-]{subsection.3.7.1}{Each index in the example}{section.3.7}% 29
\BOOKMARK [1][-]{section.3.8}{Writing the algorithm for converting infix expression to equivalent post-fix}{chapter.3}% 30
\BOOKMARK [1][-]{section.3.9}{Combine the conversion and evaluation function in a single program}{chapter.3}% 31
\BOOKMARK [0][-]{chapter.4}{All about the queue}{}% 32
\BOOKMARK [1][-]{section.4.1}{Introduction to the queue}{chapter.4}% 33
\BOOKMARK [2][-]{subsection.4.1.1}{Formal definition}{section.4.1}% 34
\BOOKMARK [2][-]{subsection.4.1.2}{Some other variations of the queue data structure}{section.4.1}% 35
\BOOKMARK [1][-]{section.4.2}{The FIFO queue implementation idea using array}{chapter.4}% 36
\BOOKMARK [1][-]{section.4.3}{Algorithm for FIFO Queue}{chapter.4}% 37
\BOOKMARK [2][-]{subsection.4.3.1}{Enqueue}{section.4.3}% 38
\BOOKMARK [2][-]{subsection.4.3.2}{Dequeue}{section.4.3}% 39
\BOOKMARK [1][-]{section.4.4}{Implementation of FIFO Queue}{chapter.4}% 40
\BOOKMARK [1][-]{section.4.5}{The loophole in our implementation of FIFO queue}{chapter.4}% 41
\BOOKMARK [1][-]{section.4.6}{Understanding the loophole, why it happens?}{chapter.4}% 42
\BOOKMARK [1][-]{section.4.7}{Introduction to circular queue}{chapter.4}% 43
\BOOKMARK [1][-]{section.4.8}{Circular queue operations}{chapter.4}% 44
\BOOKMARK [1][-]{section.4.9}{Algorithms for enqueue and dequeue operations for a circular queue}{chapter.4}% 45
\BOOKMARK [2][-]{subsection.4.9.1}{Enqueue}{section.4.9}% 46
\BOOKMARK [2][-]{subsection.4.9.2}{Dequeue}{section.4.9}% 47
\BOOKMARK [1][-]{section.4.10}{Implementation of Circular Queue}{chapter.4}% 48
\BOOKMARK [1][-]{section.4.11}{Introduction to Double Ended Queue}{chapter.4}% 49
\BOOKMARK [2][-]{subsection.4.11.1}{Example}{section.4.11}% 50
\BOOKMARK [1][-]{section.4.12}{Algorithm development for double ended queue operations}{chapter.4}% 51
\BOOKMARK [2][-]{subsection.4.12.1}{Insertion at rear}{section.4.12}% 52
\BOOKMARK [2][-]{subsection.4.12.2}{Delete from rear}{section.4.12}% 53
\BOOKMARK [2][-]{subsection.4.12.3}{Insert at front}{section.4.12}% 54
\BOOKMARK [2][-]{subsection.4.12.4}{Deletion from front}{section.4.12}% 55
\BOOKMARK [1][-]{section.4.13}{Implementation of double ended queue}{chapter.4}% 56
\BOOKMARK [0][-]{chapter.5}{Linked List}{}% 57
\BOOKMARK [1][-]{section.5.1}{Introduction to linked lists}{chapter.5}% 58
\BOOKMARK [2][-]{subsection.5.1.1}{What is wrong with arrays?}{section.5.1}% 59
\BOOKMARK [1][-]{section.5.2}{Definition of linked list, conception of node, understanding basic principles}{chapter.5}% 60
\BOOKMARK [2][-]{subsection.5.2.1}{Example for storing a set of integers}{section.5.2}% 61
\BOOKMARK [1][-]{section.5.3}{Categories of linked lists - singly, doubly and circular linked list}{chapter.5}% 62
\BOOKMARK [2][-]{subsection.5.3.1}{Singly linked lists}{section.5.3}% 63
\BOOKMARK [2][-]{subsection.5.3.2}{Circular linked list}{section.5.3}% 64
\BOOKMARK [2][-]{subsection.5.3.3}{Double linked list}{section.5.3}% 65
\BOOKMARK [0][-]{chapter.6}{Singly linked lists}{}% 66
\BOOKMARK [1][-]{section.6.1}{Linked list operation for insert at tail}{chapter.6}% 67
\BOOKMARK [1][-]{section.6.2}{Linked list operation for inserting at head}{chapter.6}% 68
\BOOKMARK [1][-]{section.6.3}{Linked list operation for traversing singly linked lists}{chapter.6}% 69
\BOOKMARK [1][-]{section.6.4}{Linked list operation for delete first}{chapter.6}% 70
\BOOKMARK [1][-]{section.6.5}{Linked list operation for delete last}{chapter.6}% 71
\BOOKMARK [1][-]{section.6.6}{Linked list operation for deleting target nodes}{chapter.6}% 72
\BOOKMARK [1][-]{section.6.7}{Linked list operation for finding a node}{chapter.6}% 73
\BOOKMARK [1][-]{section.6.8}{Linked list operation reverse a singly linked list}{chapter.6}% 74
\BOOKMARK [1][-]{section.6.9}{Linked list operation for printing and traversing the linked list recursively}{chapter.6}% 75
\BOOKMARK [0][-]{chapter.7}{Doubly linked list}{}% 76
\BOOKMARK [1][-]{section.7.1}{Introduction to doubly linked list}{chapter.7}% 77
\BOOKMARK [1][-]{section.7.2}{Doubly linked list operation for adding node at head}{chapter.7}% 78
\BOOKMARK [1][-]{section.7.3}{Doubly linked list operation for adding node at tail}{chapter.7}% 79
\BOOKMARK [1][-]{section.7.4}{Doubly linked list operation for finding a node in the list}{chapter.7}% 80
\BOOKMARK [1][-]{section.7.5}{Doubly linked list operation for deleting node at head}{chapter.7}% 81
\BOOKMARK [1][-]{section.7.6}{Doubly linked list operation for deleting node at tail}{chapter.7}% 82
\BOOKMARK [1][-]{section.7.7}{Doubly linked list operation for deleting a target node}{chapter.7}% 83
\BOOKMARK [1][-]{section.7.8}{Doubly linked list for traversing and printing data of the doubly linked list}{chapter.7}% 84
\BOOKMARK [0][-]{chapter.8}{Circular linked lists}{}% 85
\BOOKMARK [1][-]{section.8.1}{Introduction}{chapter.8}% 86
\BOOKMARK [2][-]{subsection.8.1.1}{Circular linked list visualization}{section.8.1}% 87
\BOOKMARK [1][-]{section.8.2}{Operation for inserting a node to circular linked list}{chapter.8}% 88
\BOOKMARK [1][-]{section.8.3}{Operation for finding a target node in circular linked list}{chapter.8}% 89
\BOOKMARK [1][-]{section.8.4}{Operation for deleting a node in circular linked list}{chapter.8}% 90
\BOOKMARK [1][-]{section.8.5}{Operation for printing nodes in circular linked list}{chapter.8}% 91
\BOOKMARK [0][-]{chapter.9}{Efficiency of an algorithm}{}% 92
\BOOKMARK [1][-]{section.9.1}{Efficiency of algorithm - Introduction to the concept}{chapter.9}% 93
\BOOKMARK [2][-]{subsection.9.1.1}{Choose between two algorithms}{section.9.1}% 94
\BOOKMARK [2][-]{subsection.9.1.2}{Hypothetical machine}{section.9.1}% 95
\BOOKMARK [2][-]{subsection.9.1.3}{We are interested in input size}{section.9.1}% 96
\BOOKMARK [1][-]{section.9.2}{Mathematical approach for finding the efficiency}{chapter.9}% 97
\BOOKMARK [2][-]{subsection.9.2.1}{Drawbacks}{section.9.2}% 98
\BOOKMARK [1][-]{section.9.3}{We want a theoretical way based on mathematics to compare the efficiency of the algorithms}{chapter.9}% 99
\BOOKMARK [2][-]{subsection.9.3.1}{Example of what we want as a metric}{section.9.3}% 100
\BOOKMARK [2][-]{subsection.9.3.2}{Example of Big-O}{section.9.3}% 101
\BOOKMARK [1][-]{section.9.4}{How to calculate Big-O for a given algorithm}{chapter.9}% 102
\BOOKMARK [2][-]{subsection.9.4.1}{Finding Big-O}{section.9.4}% 103
\BOOKMARK [1][-]{section.9.5}{Another approach for calculating Big-O - recurrence relationship}{chapter.9}% 104
\BOOKMARK [2][-]{subsection.9.5.1}{Another example}{section.9.5}% 105
\BOOKMARK [1][-]{section.9.6}{Another example}{chapter.9}% 106
\BOOKMARK [2][-]{subsection.9.6.1}{The same but evaluated with recurrence}{section.9.6}% 107
\BOOKMARK [1][-]{section.9.7}{Idea of best case complexity \204 Big Omega notation}{chapter.9}% 108
\BOOKMARK [2][-]{subsection.9.7.1}{Finding Big- \(best case complexity\)}{section.9.7}% 109
\BOOKMARK [2][-]{subsection.9.7.2}{An example}{section.9.7}% 110
\BOOKMARK [1][-]{section.9.8}{Idea of average case complexity \204 Big theta notation}{chapter.9}% 111
\BOOKMARK [2][-]{subsection.9.8.1}{Big theta on polynomials}{section.9.8}% 112
\BOOKMARK [0][-]{chapter.10}{Binary search}{}% 113
\BOOKMARK [1][-]{section.10.1}{Binary search}{chapter.10}% 114
\BOOKMARK [2][-]{subsection.10.1.1}{Example}{section.10.1}% 115
\BOOKMARK [2][-]{subsection.10.1.2}{Searching the upper part}{section.10.1}% 116
\BOOKMARK [2][-]{subsection.10.1.3}{Searching the lower part}{section.10.1}% 117
\BOOKMARK [2][-]{subsection.10.1.4}{When the target is not on the list}{section.10.1}% 118
\BOOKMARK [1][-]{section.10.2}{Implementation}{chapter.10}% 119
\BOOKMARK [1][-]{section.10.3}{Worst case complexity}{chapter.10}% 120
\BOOKMARK [0][-]{chapter.11}{Recursion}{}% 121
\BOOKMARK [1][-]{section.11.1}{Introduction to recursion}{chapter.11}% 122
\BOOKMARK [1][-]{section.11.2}{Basic concept of recursion}{chapter.11}% 123
\BOOKMARK [1][-]{section.11.3}{When and how to terminate \204 the base condition of recursion}{chapter.11}% 124
\BOOKMARK [1][-]{section.11.4}{Let us go into the depth of the call}{chapter.11}% 125
\BOOKMARK [1][-]{section.11.5}{Recursion example \204 Juggler Sequence}{chapter.11}% 126
\BOOKMARK [1][-]{section.11.6}{Recursion example \204 Finding Factorial}{chapter.11}% 127
\BOOKMARK [1][-]{section.11.7}{Recursion example \204 Binary Search}{chapter.11}% 128
\BOOKMARK [1][-]{section.11.8}{Recursion example \204 Decimal to Binary}{chapter.11}% 129
\BOOKMARK [1][-]{section.11.9}{Calling a function \204 Operating system creates a stack}{chapter.11}% 130
\BOOKMARK [1][-]{section.11.10}{When there is no need for a stack}{chapter.11}% 131
\BOOKMARK [1][-]{section.11.11}{Tail recursion}{chapter.11}% 132
\BOOKMARK [1][-]{section.11.12}{Recursion versus iteration}{chapter.11}% 133
\BOOKMARK [2][-]{subsection.11.12.1}{When both are equivalent}{section.11.12}% 134
\BOOKMARK [2][-]{subsection.11.12.2}{When a loop is better}{section.11.12}% 135
\BOOKMARK [2][-]{subsection.11.12.3}{When recursion is better}{section.11.12}% 136
\BOOKMARK [2][-]{subsection.11.12.4}{Synthesis in a programmer's way}{section.11.12}% 137
\BOOKMARK [0][-]{chapter.12}{Binary tree and binary search tree}{}% 138
\BOOKMARK [1][-]{section.12.1}{Introduction to binary tree}{chapter.12}% 139
\BOOKMARK [2][-]{subsection.12.1.1}{Examples of binary trees}{section.12.1}% 140
\BOOKMARK [2][-]{subsection.12.1.2}{Valid examples and non-valid examples}{section.12.1}% 141
\BOOKMARK [1][-]{section.12.2}{Formal definition}{chapter.12}% 142
\BOOKMARK [1][-]{section.12.3}{Understanding different terminologies related with binary trees}{chapter.12}% 143
\BOOKMARK [2][-]{subsection.12.3.1}{Example}{section.12.3}% 144
\BOOKMARK [1][-]{section.12.4}{Two tree / strictly binary tree}{chapter.12}% 145
\BOOKMARK [1][-]{section.12.5}{Complete binary tree / full tree}{chapter.12}% 146
\BOOKMARK [1][-]{section.12.6}{How to traverse a binary tree}{chapter.12}% 147
\BOOKMARK [2][-]{subsection.12.6.1}{In-order traversal strategy}{section.12.6}% 148
\BOOKMARK [2][-]{subsection.12.6.2}{Pre-order traversal strategy}{section.12.6}% 149
\BOOKMARK [2][-]{subsection.12.6.3}{Post-order traversal strategy}{section.12.6}% 150
\BOOKMARK [1][-]{section.12.7}{Constructing a binary tree from a given traversal list}{chapter.12}% 151
\BOOKMARK [2][-]{subsection.12.7.1}{Developing the tree using the in-order and pre-order lists}{section.12.7}% 152
\BOOKMARK [2][-]{subsection.12.7.2}{Developing a tree from in-order and post-order traversal lists}{section.12.7}% 153
\BOOKMARK [1][-]{section.12.8}{How to define a structure of a Node for a binary tree}{chapter.12}% 154
\BOOKMARK [1][-]{section.12.9}{Binary search tree}{chapter.12}% 155
\BOOKMARK [1][-]{section.12.10}{Binary tree implementation}{chapter.12}% 156
\BOOKMARK [0][-]{chapter.13}{Heap}{}% 157
\BOOKMARK [1][-]{section.13.1}{Introduction}{chapter.13}% 158
\BOOKMARK [1][-]{section.13.2}{Almost complete binary}{chapter.13}% 159
\BOOKMARK [1][-]{section.13.3}{Representing an almost complete binary tree as an array}{chapter.13}% 160
\BOOKMARK [1][-]{section.13.4}{Formal definition of heap}{chapter.13}% 161
