\section{Decorators in Python}
\begin{itemize}
    \item It's an on/off switch that lets a function activate extra functionality meanwhile maintaining the original (w/o the new functionality). 
    \item It consists of an anidated function which wraps the parameter function with a before and after code.
    \item They are used in web frameworks such as Django or Flask.
    \item In the below examples there are two ways to decorate a function one with the @ operator and the other without the @ operator. 
\end{itemize}

\subsection{Example without the @ operator}
\begin{minted}[autogobble]{python}
    def new_decorator(original_func):
        def wraper_func():
            print("Some code actions before your original function")
            original_func()
            print("Some code actions after your original function")
        return wraper_func
    def func_deco():
        print("This is the code intended to be decorated")
    decorated_func = new_decorator(func_deco)
    decorated_func()
    # output: Some code actions before your original function
    # output: This is the code intended to be decorated
    # output: Some code actions after your original function
\end{minted}

\subsection{Example with the @ operator}
\begin{minted}[autogobble]{python}
    # Using a decorator syntax
    @new_decorator
    def func_deco():
        print("This is the code intended to be decorated")
    func_deco()
    # output: Some code actions before your original function
    # output: This is the code intended to be decorated
    # output: Some code actions after your original function
\end{minted}
