\section{Introduction to linked lists}
\begin{itemize}
    \item Linked lists resolve the problems commonly encountered with arrays, that is the fact that arrays have to be declared of a fixed size and can't really be dynamically grown without fragmenting memory is a problem we can resolve using a linked list data structure.
    \item The draw backs of arrays are actually removed with linked lists at the cost of the benefits of having an array.
\end{itemize}

\subsection{What is wrong with arrays?}
\begin{itemize}
    \item The first issue with array is the size of the array needs to be declared. Using realloc() will not really resolve this because it will copy all the elements of the array in to a bigger memory location, this causes poor performance and fragmentation. 
    \item Once allocated with a size it is a hazard to change the size of the array in runtime.
    \item Another issue is performing the insertion and deletion operation at any point between the first and the last index of the existing elements. An example can clarify this problem.
        \input{figs/array_defect.tex}
    
    \item Adding a new element or deleting an existing element is independent to the number of elements in the linked list, no shifting kind of activities like arrays are required. 
\end{itemize}


%----------------------------------------------------------------------------------------
\section{Definition of linked list, conception of node, understanding basic principles}
\begin{itemize}
    \item Linked lists are dynamic, created on ``as and when required basis''.
    \item We don't need to specify the size in a linked list.
    \item Elements in a linked list are discrete, not contiguous like arrays.
\end{itemize}

\subsection{Example for storing a set of integers}
\begin{itemize}
    \item Lets declared a structure or node in this case containing members int and pointer. The int is to store the data and the pointer is to store the address of the next node. 
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[]{\figs/introll} 
\end{figure}


%----------------------------------------------------------------------------------------
\section{Categories of linked lists - singly, doubly and circular linked list}

\subsection{Singly linked lists}
\begin{itemize}
    \item Consists of nodes containing a data and pointer member, each pointer points to the next node and the tail is recognized when a null pointer is encountered. 
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[]{\figs/introsll} 
\end{figure}

\subsection{Circular linked list}
\begin{itemize}
    \item In circular linked list there is no head, there is only a tail pointer, the tail pointer points to the last node's address.
    \item The terminal node does not point to null, it points to the first member of the linked list.
    \item This is based on the circular queue model.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[]{\figs/clist} 
\end{figure}

\subsection{Double linked list}
\begin{itemize}
    \item In this linked list, each node has two pointers, one that points to the next node and the other that points to the previous node. 
    \item The previous pointer in the first node and the next pointer in the terminal node are always pointing to null. 
    \item This is a way of implementing a dynamic double ended queue. 
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[]{\figs/dllintro} 
\end{figure}
