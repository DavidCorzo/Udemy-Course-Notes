%----------------------------------------------------------------------------------------
\section{What is a variable?}
\begin{itemize}
    \item A variable allows us to use a name for a memory location in RAM in which our variable is stored.
    \item A variable is an abstraction for a memory location. 
    \item Variables allow programmers to use meaninful names and not memory addresses. 
    \item Variables have: 
        \begin{itemize}
            \item Type: their category (integer, real number, string, objects).
            \item Value: the content (10, 3.14, "String").
        \end{itemize}
    
    \item Variables must be declared before they are used. 
    \item A variable value may change.
    \item Example: 
        \begin{minted}[autogobble]{cpp}
            age = 21; // Compiler error.
        \end{minted}
        In the above code we never declared age so the compiler does not know how much memory to allocate for the variable, thus a compiler error is produced, age was never declared. This is called static typing because all the rules are enforced when the program is compiled rather than when the program is running.
        \begin{minted}[autogobble]{cpp}
            int age; 
            age = 21;
        \end{minted}
        The above code is correct.
\end{itemize}


%----------------------------------------------------------------------------------------
\section{Declaring and initializing variables}
\begin{itemize}
    \item The syntax is: \verb|<variable_type> <variable_name>;|.
    \item Variable types can be anything, such as: \mintinline{cpp}{int, double, float, string} you can also declare user defined types (this is object oriented programming) such as \mintinline{cpp}{Account, Person} with the same syntax you would use with any other type.
\end{itemize}

\subsection{Naming rules and conventions}
\begin{itemize}
    \item Naming variables: 
        \begin{itemize}
            \item Can contain letters, numbers and underscores.
            \item Must begin with a letter to underscore.
                \begin{itemize}
                    \item Cannot begin with a number digit.
                \end{itemize}
            \item Cannot use C++ reserved keywords.
            \item Cannot redeclare a name in the same scope.
                \begin{itemize}
                    \item Remember that C++ is case sensative.
                \end{itemize}
            
            \item Example: 
                \begin{center}
                    \begin{tabular}{ |c|c| }
                        \hline
                            Legal & Illegal \\
                        \hline
                            Age & int \\ 
                            age & \$age \\ 
                            \_age & 2014\_age \\ 
                            My\_age & My age \\ 
                            your\_age\_in\_2014 & Age+1 \\ 
                            INT & cout \\ 
                            Int & return \\ 
                        \hline
                    \end{tabular}
                \end{center}
        \end{itemize}
    \item The best thing to do is to be consistent with your naming conventions.
        \begin{itemize}
            \item Stick to the convention you chose from the beggining.
            \item Avoid beginning names with underscores.
        \end{itemize}
    
    \item Use meaningful names:
        \begin{itemize}
            \item Not too long and not too short.
        \end{itemize}
    \item Never use variables before initializing them.
        \begin{itemize}
            \item Using variables before initializing can cause undefined behaviour.
        \end{itemize}
    \item Declare variables close to when you need them in your code.
\end{itemize}


\subsection{Declaring and initializing}
\begin{itemize}    
    \item There are many ways of initializing variables. And all reflect the way C++ has advanced as the years have passed.
        \begin{minted}[autogobble]{cpp}
            int age; // uninitialized.
            int age = 21; // C-Like initialization.
            int age (21); // Constructor initialization.
            int age {21}; // C++11 list initialization syntax.
        \end{minted}
    
    \item Using the \verb|{}| list intialization will also check if the assigned values cause an overflow in the program.
\end{itemize}

\subsection{Example}
\begin{minted}[autogobble]{cpp}
    #include <iostream>
    using namespace std;

    int main() {
        int room_width {0};
        cout << "Enter the width of the room: ";
        cin >> room_width;

        cout << "Enter the lenght of the room: ";
        int room_lenght {0};
        cin >> room_lenght;

        cout << "The area is " << room_width*room_lenght << endl;
        return 0;
    }
\end{minted}


%----------------------------------------------------------------------------------------
\section{Global variables}
\begin{itemize}
    \item Variables declared outside of any function are called global variables and they can be accessed in any point of your program.
    \item Since they can be accessed by any part of the program this also means they can be changed by any part of the program which could mean the likelyhood for bugs is higher.
    \item Local variables are declared and used within a part of the code, as your code progresses out of scope these variables are automatically destoyed.
    \item Local variables have higher precedence than global variables, if you call a local and global variable the same and decide to use one of both the local is going to be prioritized and the global variable will no be used.
\end{itemize}


%----------------------------------------------------------------------------------------
\section{C++ Built-in Primitive Types}
\begin{itemize}
    \item These are sometimes called fundamental data types because they are implemented directly by the C++ language.
    \item They include: 
        \begin{itemize}
            \item Character type.
            \item Integer type.
                \begin{itemize}
                    \item signed and unsigned.
                \end{itemize}
            \item Floating-point types.
            \item Boolean types.
        \end{itemize}
    \item Size and precision is often compiler dependent, this means you must be aware how much storage is allocated for each type. The C++ library \mintinline{cpp}{#include <climits>} conatins information about your specific compiler.
\end{itemize}

\subsection{Type sizes}
\begin{itemize}
    \item A computer works by storing bits on memory, data types are stored in bits. 
    \item The more bits the more values that can be represented. 
    \item The more bits the more storage requiered.
    \item The computer however is not conserned with bits but with bytes, a byte is 8 bits stored continously in memory. To find out how many values you can store with $n$ number of bits the formula is $2^n$, below are some examples:  
        \begin{center}
            \begin{tabular}{ |c|c|c| }
                \hline
                    Size (in bits) & Representable values &  \\
                \hline
                    8 & 256 & $2^8$ \\ 
                    16 & 65,536 & $2^{16}$ \\ 
                    32 & 4,294,927,296 & $2^{32}$ \\ 
                    64 & 18,446,744,073,551,615 & $2^{64}$ \\ 
                \hline
            \end{tabular}
        \end{center}
\end{itemize}

\subsection{Character types}
\begin{itemize}
    \item Used to represent single characters: 'A', 'X', '@'.
    \item Wider types are used to represent wide character sets.
        \begin{center}
            \begin{tabular}{ |c|c| }
                \hline
                    Type name & Size / Precision \\
                \hline
                    char & Exactly one byte. At least 8 bits. \\ 
                    char16\_t & At least 16 bits. \\
                    char32\_t & At least 32 bits. \\
                    wchar\_t & Can represent the largest available character set. \\
                \hline
            \end{tabular}
        \end{center}
    
    \item Example: 
        \begin{minted}[autogobble]{cpp}
            char m {'j'};
            cout << m << endl;
        \end{minted}
\end{itemize}

\subsection{Integer data types}
\begin{itemize}
    \item Used to represent whole numbers.
    \item Signed and unsigned versions.
        \begin{center}
            \begin{tabular}{ |c|c| }
                \hline
                    Type & Size / Precision \\
                \hline
                    signed short int & At least 16 bits. \\ 
                    signed int & At least 16 bits.  \\ 
                    signed long int & At least 32 bits. \\ 
                    signed long long int & At least 64 bits. \\ 
                \hline
            \end{tabular}
            \begin{tabular}{ |c|c| }
                \hline
                    Type & Size / Precision \\
                \hline
                    unsigned short int & At least 16 bits. \\ 
                    unsigned int & At least 16 bits.  \\ 
                    unsigned long int & At least 32 bits. \\ 
                    unsigned long long int & At least 64 bits. \\ 
                \hline
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item Ints can be overflowed, when an overflow happens you can have undefined behaviour.
        \end{itemize}

    \item Example: 
        \begin{minted}[autogobble]{cpp}
            unsigned short int exam_score {55};
            cout << exam_score << endl;
            int countries_represented {65};
            cout << countries_represented << endl;
            long people_in_florida {2061100000};
            cout << people_in_florida << endl;
            long long people_on_earth {7'600'000'000};
            cout << people_on_earth << endl;
            long long distance_to_alpha_century {9'461'000'000'000};
            cout << distance_to_alpha_century << endl;
        \end{minted}
\end{itemize}

\subsection{Floating point type}
\begin{itemize}
    \item Used to represent non-integer numbers.
    \item Represented by mantissa and exponent (scientific notation).
    \item Precision is the number of digits in the mantissa.
    \item Precission and size are compiler dependent.
        \begin{center}
            \begin{tabular}{ |c|c|c| }
                \hline
                    Type name & Size / Typical Precision & Typical Range \\
                \hline
                    float & /7 decimal digits & $1.2\times 10^{-38}$ to $3.4\times 10^{38}$  \\ 
                    double & No less than float / 15 decimal digits & $2.2\times 10^{-308}$ to $1.8\times 10^{308}$  \\ 
                    float & No less than double / 19 decimal digits & $3.3\times 10^{-4932}$ to $1.2\times 10^{4932}$  \\ 
                \hline
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item Remember there is no such thing yet as storing an infinitely precise decimal such as $\pi$ computers store approximations using scientific notation.
        \end{itemize}
    \item Example: 
        \begin{minted}[autogobble]{cpp}
            float car_payment {401.23};
            cout << car_payment << endl;
            double pi {3.14159};
            cout << pi << endl;
            long double large_amount {2.7e120};
            cout << large_amount << endl;
        \end{minted}
\end{itemize}

\subsection{Boolean type}
\begin{itemize}
    \item Used to represnt true and false.
    \item Zero is false. 
    \item Non-zero is true.
        \begin{center}
            \begin{tabular}{ |c|c| }
                \hline
                    Type name & Size / Precision \\
                \hline
                    bool & Usually 8 bits true or false (C++ Keywords) \\ 
                \hline
            \end{tabular}
        \end{center}

    \item Example: 
        \begin{minted}[autogobble]{cpp}
            bool game_over {false};
            cout << game_over << endl;
        \end{minted}
\end{itemize}

\subsection{Buffer overflows}
\begin{minted}[autogobble]{cpp}
    short val1 {30'000};
    short val2 {1'000};
    short product {va1 * val2}; // overflow, maximum is about 32,000.
\end{minted}



%----------------------------------------------------------------------------------------
\section{What is the size of a variable?}
\begin{itemize}
    \item The \mintinline{cpp}{sizeof} operator determines the size in bytes of a type or variable.
    \item Examples: 
        \begin{minted}[autogobble]{cpp}
            sizeof(int);
            sizeof(double);
            sizeof(some_variable);
            sizeof some_variable; // parenthesis are optional for variables.
        \end{minted}
    
    \item The sizeof operator gets its information from two C++ include files. \mintinline{cpp}{<climits> <cfloat>}, the climits and cfloat influde files contain size and precision information about your implemntation of C++. These libraries also provide information constants such as \verb|INT_MAX, INT_MIN, LONG_MAX, LONG_MIN, FLT_MIN, FLT_MAX, ...|.
\end{itemize}

\subsection{Examples}
*Take into account that the values returned by the sizeof operator will be different depending on your machine.
\begin{minted}[autogobble]{cpp}
    #include <iostream>
    #include <climits>
    using namespace std;
    int main() {
        cout << "sizeof: " << endl;
        cout << "char: " << sizeof(char) << endl;
        cout << "int: " << sizeof(int) << endl;
        cout << "unsigned int: " << sizeof(unsigned int) << endl;
        cout << "short: " << sizeof(short) << endl;
        cout << "long: " << sizeof(long) << endl;
        cout << "long long: " << sizeof(long long) << endl;
        cout << "float: " << sizeof(float) << endl;
        cout << "double: " << sizeof(double) << endl;
        cout << "long double: " << sizeof(long double) << endl;
        cout << "=================<climits>==================" << endl;
        cout << "climits minimum vals" << endl;
        cout << "char: " << CHAR_MIN << endl;
        cout << "int: " << INT_MIN << endl;
        cout << "short: " << SHRT_MIN << endl;
        cout << "long: " << LONG_MIN << endl;
        cout << "long long: " << LLONG_MIN << endl;
        cout << "climits maximum vals" << endl;
        cout << "char: " << CHAR_MAX << endl;
        cout << "int: " << INT_MAX << endl;
        cout << "short: " << SHRT_MAX << endl;
        cout << "long: " << LONG_MAX << endl;
        cout << "long long: " << LLONG_MAX << endl;
        cout << "=================sizeof variable names==================" << endl;
        int age {21};
        cout << "age is " << sizeof(age) << endl;
        double wage {22.24};
        cout << "wage is " << sizeof(wage) << endl;
        return 0;
    }
    /* OUTPUT: 
    sizeof: 
    char: 1 
    int: 4
    unsigned int: 4
    short: 2
    long: 4
    long long: 8
    float: 4
    double: 8
    long double: 16
    =================<climits>==================
    climits minimum vals
    char: -128
    int: -2147483648
    short: -32768
    long: -2147483648
    long long: -9223372036854775808
    climits maximum vals
    char: 127
    int: 2147483647
    short: 32767
    long: 2147483647
    long long: 9223372036854775807
    =================sizeof variable names==================
    age is 4
    wage is 8
    */
\end{minted}


%----------------------------------------------------------------------------------------
\section{What is a constant?}
\begin{itemize}
    \item Constants are very much like variables in C++. 
    \item The follow the same naming convensions of variables.
    \item They occupy storage.
    \item And they are usually typed. 
    \item However, their value cannot change once declared. 
\end{itemize}

\subsection{Literal constants}
\begin{itemize}
    \item The most obvious kind of constant. 
    \item Integer literal constants:
        \begin{itemize}
            \item \mintinline{cpp}{12} an integer.
            \item \mintinline{cpp}{12U} an unsigned integer.
            \item \mintinline{cpp}{12L} a long integer.
            \item \mintinline{cpp}{12LL} a long long integer.
        \end{itemize}
    \item Floating-point literal constants:
        \begin{itemize}
            \item \mintinline{cpp}{12.1} a double.
            \item \mintinline{cpp}{12.1F} a float.
            \item \mintinline{cpp}{12.1L} a long double.
        \end{itemize}
    \item Character literal constants (escape codes).
        \begin{itemize}
            \item \mintinline{cpp}{\n} newline.
            \item \mintinline{cpp}{\r} return.
            \item \mintinline{cpp}{\t} tab.
            \item \mintinline{cpp}{\b} backspace. 
            \item \mintinline{cpp}{\'} single quote.
            \item \mintinline{cpp}{\"} double quote.
            \item \mintinline{cpp}{\\} backslash.
        \end{itemize}
\end{itemize}

\subsection{Defined constants}
\begin{itemize}
    \item Constants that are declared using the \mintinline{cpp}{const} keyword.
        \begin{minted}[autogobble]{cpp}
            const double pi {3.1415926};
            const int months_in_year {12};
            pi = 2.5; // compiler error.
        \end{minted}
\end{itemize}

\subsubsection{Defined constants}
\begin{itemize}
    \item Constants defined as preprocessor directive. 
        \begin{minted}[autogobble]{cpp}
            #define pi 3.1415926
        \end{minted}
    
    \item Notice you don't declare a type, this is sort of a blind find and replace done before compilation of the program, whenever the program encounters \mintinline{cpp}{pi} it will replace it with the value of the define constant, since the preprocessor does not know C++ it can't type check and this can make it difficult to find errors. The best is to never define constants and to always use the \mintinline{cpp}{const} keyword in your code.
\end{itemize}


%----------------------------------------------------------------------------------------

