{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Qcpp12LL a long long integer.\\E$"}
{"rule":"SENTENCE_FRAGMENT","sentence":"^\\QWhich means they are data types made out of other data types.\\E$"}
{"rule":"THERE_S_MANY","sentence":"^\\QThere is no bounds checking.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qothers that work with objects and pointers which will be introduced later.\\E$"}
{"rule":"DT_JJ_NO_NOUN","sentence":"^\\QThese operators compare the values of two expressions and evaluate to a boolean.\\E$"}
{"rule":"SENTENCE_FRAGMENT","sentence":"^\\QWhile specific condition(s) remains true.\\E$"}
{"rule":"SENTENCE_FRAGMENT","sentence":"^\\QUntil a specific condition becomes false.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QUnderstand what the function returns.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QUnderstand any errors the function my produce.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QUnderstand any performance constraints.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QDivide the rest of the problem into subproblems and do a recursive call.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QPointers can be uninitialized.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAllocating and deallocating memory.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q#include <iostream> using namespace std; int main() int scores[] 100,95,89; cout << scores << endl; cout << *scores << endl; int *score_ptr scores; cout << score_ptr << endl; cout << *score_ptr << endl; return 0; /* OUTPUT: 0x61fe0c 100 0x61fe0c 100 */ We can also use array subscripting on a pointer.\\E$"}
